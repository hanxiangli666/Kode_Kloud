# Day 100: Create and Configure Alarm Using CloudWatch Using Terraform

## Task Overview

Build a complete monitoring infrastructure using Terraform, including an EC2 instance, CloudWatch alarm for CPU utilization monitoring, and SNS topic for alert notifications. This demonstrates proactive monitoring and automated alerting for AWS resources to ensure optimal application performance.

**Technical Specifications:**
- EC2 instance: nautilus-ec2 (Ubuntu AMI: ami-0c02fb55956c7d316)
- Instance type: t2.micro
- CloudWatch alarm: nautilus-alarm
- Metric: CPU Utilization (Average)
- Threshold: >= 90% for 1 consecutive 5-minute period
- SNS topic: nautilus-sns-topic (notification destination)
- Region: us-east-1

**Lab:** [KodeKloud Engineer Platform](https://engineer.kodekloud.com/practice)

---

## Solution Steps

**Step 1:** Navigate to the Terraform working directory

```sh
cd /home/bob/terraform
```

Change to the Terraform working directory where you'll create configuration files for EC2 instance monitoring infrastructure. This directory will contain all Terraform files for the monitoring stack.

**Step 2:** Create the variables.tf file

```sh
# Create variables.tf file in VS Code or text editor
# Right-click under EXPLORER section and select "New File"
# Name it: variables.tf
```

Create a variables file to define the naming prefix that will be used consistently across all resources. Using variables ensures consistent naming and makes the configuration reusable.

**Step 3:** Define variable in variables.tf

```hcl
variable "prefix" {
    default = "nautilus"
}
```

Define a single variable for the resource naming prefix with a default value of `nautilus`. This prefix will be used to name the EC2 instance, SNS topic, and CloudWatch alarm, ensuring all related resources are easily identifiable and grouped together in the AWS console. Update this value to match your specific task requirements.

**Step 4:** Create the main.tf file

```sh
# Create main.tf file in VS Code or text editor
# Name it: main.tf
```

Create the main Terraform configuration file where you'll define the SNS topic, EC2 instance, and CloudWatch alarm resources. These three resources work together to provide monitoring and alerting.

**Step 5:** Define SNS topic in main.tf

```hcl
resource "aws_sns_topic" "sns_topic" {
    name = "${var.prefix}-sns-topic"
}
```

Create an SNS (Simple Notification Service) topic that will receive alarm notifications. The `name` uses string interpolation to combine the prefix with `-sns-topic`, resulting in `nautilus-sns-topic`. SNS topics act as communication channels that can send messages to multiple subscribers (email, SMS, HTTP endpoints, Lambda functions, etc.). The CloudWatch alarm will publish messages to this topic when the CPU threshold is breached. Note that while the topic is created here, you would need to create subscriptions separately (via AWS console or additional Terraform resources) to actually receive notifications.

**Step 6:** Define EC2 instance in main.tf

```hcl
resource "aws_instance" "ec2_instance" {
    ami = "ami-0c02fb55956c7d316"
    instance_type = "t2.micro"

    tags = {
        Name = "${var.prefix}-ec2"
    }
}
```

Create an EC2 instance using the specified Ubuntu AMI. The `ami` parameter uses the provided AMI ID `ami-0c02fb55956c7d316`, which is a Ubuntu image in the us-east-1 region. The `instance_type = "t2.micro"` provides minimal compute resources (1 vCPU, 1GB RAM), which is free tier eligible and suitable for testing. The `tags` block sets the instance name to `nautilus-ec2` using string interpolation. This instance will be monitored by the CloudWatch alarm created in the next step. Since no security group or subnet is specified, the instance will use the default VPC and security group.

**Step 7:** Define CloudWatch metric alarm in main.tf

```hcl
resource "aws_cloudwatch_metric_alarm" "cw_alarm" {
    alarm_name = "${var.prefix}-alarm"
    comparison_operator = "GreaterThanOrEqualToThreshold"
    evaluation_periods = 1
    metric_name = "CPUUtilization"
    namespace = "AWS/EC2"
    period = 300
    statistic = "Average"
    threshold = 90

    dimensions = {
        InstanceId = aws_instance.ec2_instance.id
    }

    alarm_actions = [aws_sns_topic.sns_topic.arn]
}
```

Create a CloudWatch alarm that monitors CPU utilization and triggers when it exceeds 90%. Let's break down each parameter:

**Alarm Configuration:**
- `alarm_name`: Sets the alarm name to `nautilus-alarm` using the prefix variable
- `comparison_operator = "GreaterThanOrEqualToThreshold"`: Triggers when metric >= threshold
- `evaluation_periods = 1`: Number of periods to evaluate (1 period = breach triggers alarm)
- `threshold = 90`: The threshold value (90%)

**Metric Definition:**
- `metric_name = "CPUUtilization"`: The specific metric to monitor
- `namespace = "AWS/EC2"`: AWS service namespace (EC2 provides CPU metrics by default)
- `period = 300`: Time interval in seconds (300 seconds = 5 minutes)
- `statistic = "Average"`: Aggregation method (Average CPU over the period)

**Targeting:**
- `dimensions.InstanceId`: Targets the specific EC2 instance using its ID
- `aws_instance.ec2_instance.id`: Creates implicit dependency on EC2 instance

**Actions:**
- `alarm_actions`: List of ARNs to notify when alarm triggers
- `[aws_sns_topic.sns_topic.arn]`: Sends notification to the SNS topic

The alarm works as follows: Every 5 minutes, CloudWatch calculates the average CPU utilization. If the average is >= 90% for 1 consecutive period (5 minutes), the alarm transitions to ALARM state and publishes a notification to the SNS topic.

**Step 8:** Create the outputs.tf file

```sh
# Create outputs.tf file in VS Code or text editor
# Name it: outputs.tf
```

Create an outputs file to display resource names after deployment. The task requires specific output variable names for validation.

**Step 9:** Define outputs in outputs.tf

```hcl
output "KKE_instance_name" {
    value = aws_instance.ec2_instance.tags["Name"]
}

output "KKE_alarm_name" {
    value = aws_cloudwatch_metric_alarm.cw_alarm.alarm_name
}
```

Define two outputs with specific names required by the task. The `KKE_instance_name` output extracts the Name tag from the EC2 instance, returning `nautilus-ec2`. The `KKE_alarm_name` output retrieves the alarm name attribute, returning `nautilus-alarm`. These outputs confirm that both resources were created with the correct names.

**Step 10:** Initialize the Terraform project

```sh
terraform init
```

Initialize the Terraform working directory, downloading the AWS provider plugin that includes support for EC2, SNS, and CloudWatch resources. This command prepares your environment for creating monitoring infrastructure.

**Step 11:** Preview the infrastructure changes

```sh
terraform plan
```

Generate an execution plan showing the three resources that will be created: SNS topic, EC2 instance, and CloudWatch alarm. Review the plan to verify instance AMI, alarm threshold settings, period duration, and SNS topic configuration are correct. Terraform will display the complete alarm configuration including all metric parameters.

**Step 12:** Apply the Terraform configuration

```sh
terraform apply -auto-approve
```

Execute the plan to create all resources in AWS. Terraform creates the SNS topic and EC2 instance in parallel (they have no dependencies), then creates the CloudWatch alarm (which depends on both). The EC2 instance will take 1-2 minutes to reach the running state. Upon completion, Terraform displays the two outputs showing the instance name and alarm name, confirming successful deployment.

**Step 13:** Verify resource creation and alarm status

```bash
# List all managed resources
terraform state list

# Show detailed EC2 instance information
terraform state show aws_instance.ec2_instance

# Show CloudWatch alarm configuration
terraform state show aws_cloudwatch_metric_alarm.cw_alarm

# Show SNS topic details
terraform state show aws_sns_topic.sns_topic

# Display outputs
terraform output

# Verify in AWS CLI (if configured)
aws ec2 describe-instances --instance-ids <instance-id>
aws cloudwatch describe-alarms --alarm-names nautilus-alarm
aws sns list-topics
```

Verify successful deployment using these commands. The `terraform state list` should show three resources: EC2 instance, CloudWatch alarm, and SNS topic. The `terraform state show` commands display detailed configuration for each resource. The AWS CLI commands provide independent verification and show current alarm state (should be INSUFFICIENT_DATA initially until metrics are collected).

**Step 14:** Subscribe to SNS topic for notifications (optional)

```bash
# Subscribe email to SNS topic
aws sns subscribe \
    --topic-arn <sns-topic-arn> \
    --protocol email \
    --notification-endpoint your-email@example.com

# Confirm subscription via email link

# Or using Terraform (add to main.tf)
resource "aws_sns_topic_subscription" "email_subscription" {
    topic_arn = aws_sns_topic.sns_topic.arn
    protocol  = "email"
    endpoint  = "your-email@example.com"
}
```

To receive actual alarm notifications, subscribe to the SNS topic. The AWS CLI command creates an email subscription, which requires confirmation via email. Alternatively, add a subscription resource to your Terraform configuration. Other protocol options include SMS, HTTP/HTTPS endpoints, Lambda functions, and SQS queues.

**Step 15:** Test the alarm by generating high CPU load (optional)

```bash
# SSH to the instance
ssh -i your-key.pem ubuntu@<public-ip>

# Generate CPU load (stress test)
# Install stress tool
sudo apt update && sudo apt install -y stress

# Run stress test to use 100% CPU
stress --cpu 1 --timeout 600s

# Monitor alarm state
aws cloudwatch describe-alarms --alarm-names nautilus-alarm
```

To test the alarm, SSH to the instance and generate high CPU load using a stress testing tool. The `stress --cpu 1 --timeout 600s` command maxes out one CPU core for 10 minutes. After one 5-minute evaluation period with average CPU >= 90%, the alarm will transition to ALARM state and send a notification to the SNS topic. You can monitor the alarm state using the AWS CLI or CloudWatch console.

---

## Key Concepts

**CloudWatch Metrics:**
- Time-ordered data points representing resource performance
- EC2 provides default metrics: CPU, Network, Disk I/O
- Basic monitoring: 5-minute granularity (free)
- Detailed monitoring: 1-minute granularity (additional cost)
- Custom metrics: Application-specific data (memory, disk space, etc.)

**CloudWatch Alarms:**
- Monitor metrics and trigger actions when thresholds are breached
- Three states: OK, ALARM, INSUFFICIENT_DATA
- Evaluation periods: Number of consecutive periods to assess
- Period: Time interval for metric aggregation (60s, 300s, 3600s, etc.)
- Composite alarms: Combine multiple alarms with AND/OR logic

**Alarm Evaluation:**
- **Period (300s):** Data collection interval (5 minutes)
- **Evaluation Periods (1):** How many consecutive periods must breach
- **Statistic (Average):** Aggregation method for the period
- **Threshold (90):** Trigger point for the alarm
- Formula: If Average(CPUUtilization) >= 90 for 1 period, trigger alarm

**Comparison Operators:**
- `GreaterThanOrEqualToThreshold`: Metric >= threshold
- `GreaterThanThreshold`: Metric > threshold
- `LessThanThreshold`: Metric < threshold
- `LessThanOrEqualToThreshold`: Metric <= threshold
- Use appropriate operator based on metric type and alert intent

**Statistics Types:**
- **Average:** Mean value over the period (most common for CPU)
- **Sum:** Total of all data points (useful for counting)
- **Minimum:** Lowest value in the period
- **Maximum:** Highest value in the period
- **SampleCount:** Number of data points in the period
- **Percentile:** p99, p95, etc. (requires extended statistics)

**SNS Topic Uses:**
- Email notifications (requires subscription confirmation)
- SMS messages (text alerts)
- HTTP/HTTPS endpoints (webhooks)
- AWS Lambda functions (automated remediation)
- SQS queues (message buffering)
- Mobile push notifications (via SNS mobile)

**Alarm Actions:**
- **alarm_actions:** Triggered when alarm goes to ALARM state
- **ok_actions:** Triggered when alarm returns to OK state
- **insufficient_data_actions:** Triggered when alarm has insufficient data
- Can specify multiple ARNs for each action type
- Common targets: SNS topics, Auto Scaling policies, EC2 actions

**EC2 CPU Utilization Metric:**
- Measures percentage of allocated EC2 compute units
- Includes user, system, and steal time
- Does NOT include idle or wait time
- Affected by instance type and workload
- 100% means all allocated vCPUs are busy

**Metric Dimensions:**
- Key-value pairs that uniquely identify metrics
- EC2 dimensions: InstanceId, InstanceType, ImageId, AutoScalingGroupName
- Must match exact case (InstanceId not instanceId)
- Filters metrics to specific resources
- Required for instance-specific alarms

**Alarm Best Practices:**
- Set appropriate thresholds (90% CPU is very high)
- Use multiple evaluation periods to avoid false positives
- Create warning (70%) and critical (90%) alarms
- Test alarms after creation
- Document alarm responses in runbooks
- Use composite alarms for complex scenarios
- Regular review and adjustment of thresholds

**Monitoring Strategy:**
- **Preventive:** Set thresholds below critical levels (warning at 70%)
- **Reactive:** Set thresholds at critical levels (alarm at 90%)
- **Multiple Levels:** Warning → Critical → Emergency
- **Escalation:** Different notification channels by severity
- **Automation:** Auto Scaling, Lambda remediation

**Cost Considerations:**
- Basic monitoring (5-minute) is free for EC2
- Detailed monitoring (1-minute) costs $0.14 per instance per month
- Standard alarm costs $0.10 per alarm per month
- High-resolution alarms cost $0.30 per alarm per month
- SNS has minimal costs for notifications

---

## Validation

Test your solution using KodeKloud's automated validation.

---

## Congratulations!

You've completed the 100 Days of DevOps Challenge! This final day brings together monitoring, alerting, and automation concepts - essential skills for maintaining reliable infrastructure.

**What You've Learned:**
- Infrastructure as Code with Terraform
- AWS resource provisioning and management
- Monitoring and observability with CloudWatch
- Automated alerting with SNS
- Best practices for production infrastructure

**Next Steps:**
- Explore advanced Terraform features (modules, remote state, workspaces)
- Learn infrastructure testing (Terratest, Checkov, tfsec)
- Study CI/CD integration for Terraform
- Practice with real-world scenarios
- Contribute to open-source DevOps projects

---

[← Day 99](day-99.md)

**Source:** [100 Days of DevOps](https://engineer.kodekloud.com/practice/100-days-of-devops)
